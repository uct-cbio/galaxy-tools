#!/usr/bin/python
# Fasta sequences are selected for which a regular expression matches the header 
# -p        Project name 
# -i		Fasta input file
# -o		Matching or NON-matching fasta output file, depending on -v flag
# -r	    RegEx pattern
# -v        True or False (output NON-matching lines)
# example usage:
#                ./grep_fasta.py -p /path_to/project -i /path_to/all_trimmed.fasta -o /path_to/all_trimmed_matched.fasta -r .*[rR]_.* -v false

import sys
import re
import string
import commands
import os
from optparse import OptionParser
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord

def main():
    
    usage = "usage: %prog -p PROJECT -i INPUTFILE -o OUTPUTFILE -v (true/false)"
    parser = OptionParser(usage=usage)
    parser.add_option("-p", "--project", dest="project_dir", help="Project directory/name")
    parser.add_option("-i", "--input_fasta", dest="input_file", help="Fasta input file")
    parser.add_option("-o", "--output_fasta", dest="output_file", help="Matching or NON-matching fasta output file, depending on -v flag")
    parser.add_option("-r", "--regex", dest="pattern", help="RegEx pattern")
    parser.add_option("-v", "--invert", dest="invert", default="false", help="true or false (output NON-matching lines)")
    (options, args) = parser.parse_args()
    
    if not options.project_dir:
        print "Please specify the project name (-p PROJECT)"
        return - 1
    if not options.input_file:
        print "Please specify the fasta input file (-i INPUTFILE)"
        return - 2
    if not options.output_file:
        print "Please specify the fasta output file (-o OUTPUFILE)"
        return - 3
    if not options.pattern:
        print "Please specify the matching pattern (-r PATTERN)"
        return - 4
    if not options.invert:
        print "Please specify matching or non-matching (-v true/false)"
        return - 5
    
    if (len(args) > 0):
        print "Too many arguments given"
        return - 6
    
    project_dir = options.project_dir
    input_file = options.input_file
    output_file = options.output_file
    pattern = options.pattern
    invert = options.invert

    # input strings generated by browser/galaxy needs to be replaced
    mapped_chars = { '>' :'__gt__',
                 '<' :'__lt__',
                 '\'' :'__sq__',
                 '"' :'__dq__',
                 '[' :'__ob__',
                 ']' :'__cb__',
         '{' :'__oc__',
                 '}' :'__cc__',
                 }

    for key, value in mapped_chars.items():
        pattern = pattern.replace(value, key)

    pattern = pattern.replace('\'', '')

    projectRegEx = re.compile("^[A-Za-z0-9./\-_]+$")
    fileRegEx = re.compile("^[A-Za-z0-9./\-_]+$")
    invertRegEx = re.compile("(true)|(false)")

    if not projectRegEx.match(project_dir):
	   print "Illegal project name."
	   return - 7
    if not fileRegEx.match(output_file):
	   print "Illegal output filename."
	   return - 8
    if not fileRegEx.match(input_file):
	   print "Illegal input filename."
	   return - 9
    if not invertRegEx.match(invert):
	   print "Illegal invert option (true/false)."
	   return - 10

    timestamp = commands.getoutput("date +%Y-%m-%d_%H_%M_%S_%N")
    base_dir = project_dir + "/grep_fasta_" + timestamp 

    if not os.path.isdir(project_dir):
        os.system("mkdir " + project_dir)

    if os.path.isdir(project_dir):
        if os.path.isdir(base_dir):
            os.system("rm -rf " + base_dir)
            os.system("mkdir " + base_dir)
            os.system("cp " + input_file + " " + base_dir + "/input.fsa")
            input_file =  base_dir + "/input.fsa"
            
        else:
            os.system("mkdir " + base_dir);
            os.system("cp " + input_file + " " + base_dir + "/input.fsa")
            input_file =  base_dir + "/input.fsa"
    else:
       print "Project does not exist."
       return - 11   

    #  e.g.  pattern = ".*[rR]_.*"
    if invert == "true":
        do_invert = True
    if invert == "false":
        do_invert = False 
    
    patternRegEx = re.compile(pattern)
    fdin = open(input_file , "r");
    entries = SeqIO.parse(fdin, "fasta");
    matched_entries = [];

    # TODO need some error checking, probable id and name in header, for now only use description
    for entry in entries:
        if not do_invert and re.match(patternRegEx, entry.description):
#            print "write matching sequence: " + entry.description 
            matched_entry = SeqRecord(seq=entry.seq, id="", name="", description=entry.description)
            matched_entries.append(matched_entry)
            
        if do_invert and not (re.match(patternRegEx, entry.description)):
#            print "write NON-matching sequence: " + entry.description
            matched_entry = SeqRecord(seq=entry.seq, id="", name="", description=entry.description)
            matched_entries.append(matched_entry)
            
    fdin.close();

    tmp_file = base_dir + "/tmp.fsa"
    fdout = open(tmp_file, "w")
    SeqIO.write(matched_entries, fdout, "fasta")
    fdout.close()
    
    tmp_output_file = base_dir + "/output.fsa"
    os.system("sed \"s/> />/g\" " + tmp_file + " > " + tmp_output_file) # replace space in the header
    os.system("cp" + " " + tmp_output_file + " " + output_file) 
      
    return 0

if __name__ == "__main__":
    sys.exit(main())
